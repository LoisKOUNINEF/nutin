import { minify } from 'html-minifier-terser';
{{#unless template}}
import fs from 'fs';
import { exit } from 'process';
import { getFilesRecursive, print, isProd, isVerbose } from '../../utils/index.js';
import { PATHS } from './paths.js';
{{/unless}}

{{#if template}}export {{/if}}async function minifyHTML(html) {
  return minify(html, {
    collapseWhitespace: true,
    removeComments: true,
    removeRedundantAttributes: true,
    removeScriptTypeAttributes: true,
    removeStyleLinkTypeAttributes: true,
    useShortDoctype: true,
    keepClosingSlash: true,
    minifyCSS: true,
    minifyJS: true,
  });
}

{{#unless template}}
const TEMPLATE_REGEX =
  /const\s+(template|templateFn)\s*=?\s*(?:\(.*?\)\s*=>\s*)?`([\s\S]*?)`/gm;

async function minifyInlineHTML() {
  const extension = isProd ? '.ts' : '.js';
  const jsFiles = getFilesRecursive(PATHS.tempApp, extension);

  for (const file of jsFiles) {
    let code = fs.readFileSync(file, 'utf8');
    let hasChanges = false;

    const matches = [...code.matchAll(TEMPLATE_REGEX)];

    if (matches.length) {
      for (const match of matches) {
        const [full, , html] = match;
        const minified = await minifyHTML(html);
        const minifiedBlock = full.replace(html, minified);
        code = code.replace(full, minifiedBlock);
        hasChanges = true;
      }
    }

    if (hasChanges) {
      fs.writeFileSync(file, code, 'utf8');
      if (isVerbose) print.info(`Minified inline HTML in: ${file}`);
    }
  }
  if (isVerbose) print.boldInfo('Inline templates minified.\n');
}

minifyInlineHTML().catch((err) => {
  print.boldError(`Unexpected error: ${err.message}`);
  exit(1);
});

{{/unless}}